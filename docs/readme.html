<html>
<head>
<title>Path Planning (AI) in Platformer Games</title>
</head>
<body>
<h1>Path Planning (AI) in Platformer Games</h1>

<p>
I've been working on path planning for platformer games for a
while. My original intention was to create a scripted character in a
platformer game easily, but it can have other interesting
applications. I have a working prototype and its source code.

<ul>
<li> <a href="http://ludumdare.tabesugi.net/ppp/">Working prototype</a>
<li> <a href="https://github.com/euske/planpathplat/">Source code</a>
</ul>

<p>
<img src="movie.gif">

<h2>Handling Continuous Space</h2>

<p>
The first problem that we need to address is the continuous nature of
a platformer game. In a typical path planning, a problem is usually
represpented as a discrete space. However, in a platformer game where
characters often are affected by gravity, handling its continuous
movement is crucial. We addressed this issue by dividing the problem
into two layers: macro-level planning and micro-level planning. The
macro-level planning takes care of a coarse-grained plan such as "go
to this block" or "jump here and try to land at that block". The
micro-level planning takes care of more fine-tuned movement that
involves a continuous 2-D space. The macro-level planning is done by
using typical AI techniques like a navigation mesh, constructing a set
of possible actions at each discrete location. The micro-level
planning is done in a more greedy manner, by taking care of physical
collisions and character coordinates.

<p>
The macro-level planning can be implemented with a pretty
straightforward Dijkstra or A* search. It starts from the goal
position, and iteratively searches all the possible movements until it
reaches the initial state (the position of the character).  Each
action is associated to its next action until it reaches the goal,
forming a DAG structure. A plan graph can be dynamically constructed
and periodically updated based on the current state of the game.
Additional restrictions (e.g. space constraints and ladders) are also
considered.

<p>
<img src="plangraph.png">

<h2>Jumping / Falling</h2>

<p>
Jumping and falling is the key element of platformer games and the
core of its planning problem. It has so many parameters that using
naive methods will easily lead to computational explosion. In the
proposed method, the macro-level planner only takes care of its
starting point and ending point in the block coordinates. The planner
has to know in advance the speed of the character in question and its
jump impulse, as well as the gravity acceleration, so that it can know
where it will exactly land. The macro-level planner doesn't take care
of an actual trajectory of characters.

<p>
<img src="jumping.png">

<h2>Landing Prediction</h2>

<p>
The planner can find a solution only when the path planning is
solvable. When a character is following another character that is
jumping or falling, the goal position is considered unreachable,
making it impossible to find a solution. In a case like this, the
planner can optionally make a guess of the final landing position
based on the current speed of the character.

<p>
<img src="prediction.png">

<h2>Splinting / Double Jumping</h2>

<h2>Moving Platforms</h2>

<p>
<img src="movingplatform.png">

<h2>Source Code Structure</h2>

<p>
There are several important classes that do the logic.
They are mostly separated from the UI.

<ul>
<li> <code>Actor</code>
<li> <code>PlanAction</code>
<li> <code>PlanMap</code>
<li> <code>TileMap</code>
</ul>

<h2>Is This Smarter than Humans?</h2>

<p>
Unfortunately, no.  Due to computational limits, the current
implementation considers only a handful of ways of possible jumps at
each position. Since it uses a rectangle as an approximation of jump
trajectory, it cannot emulate a complex manuever that humans could
do. Also, since it's on block-by-block basis, it cannot consider a
possibility of barely-make-it kinds of jumps. These are mostly
complexity problems, but in some cases there might be need to give up
to find an optimal solution.
