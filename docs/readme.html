<html>
<head>
<title>Path Planning (AI) in Platformer Games</title>
</head>
<body>
<h1>Path Planning (AI) in Platformer Games</h1>

<p>
I've been working on path planning for platformer games for a
while. My original intention was to create a scripted character in a
platformer game easily, but it can have other interesting
applications. I have a working prototype and its source code.

<ul>
<li> <a href="http://ludumdare.tabesugi.net/ppp/">Working prototype</a>
<li> <a href="https://github.com/euske/planpathplat/">Source code</a>
</ul>

<p>
<img src="movie.gif">

<h2>Handling Continuous Space</h2>

<p>
The first problem that we need to address is the continuous nature of
a platformer game. In a typical path planning, a problem is usually
represpented as a discrete space. However, in a platformer game where
characters often are affected by gravity, handling its continuous
movement is crucial. We addressed this issue by dividing the problem
into two layers: macro-level planning and micro-level planning. The
macro-level planning takes care of a coarse-grained plan such as "go
to this block" or "jump here and try to land at that block". The
micro-level planning takes care of more fine-tuned movement that
involves a continuous 2-D space. The macro-level planning is done by
using typical AI techniques like a navigation mesh, constructing a set
of possible actions at each discrete location. The micro-level
planning is done in a more greedy manner, by taking care of physical
collisions and character coordinates.

<p>
The macro-level planning can be implemented with a pretty
straightforward Dijkstra or A* search. It starts from the goal
position, and iteratively searches all the possible movements until it
reaches the initial state (the position of the character).  Each
action is associated to its next action until it reaches the goal,
forming a DAG structure. A plan graph can be dynamically constructed
and periodically updated based on the current state of the game.
Additional restrictions (e.g. space constraints and ladders) are also
considered.

<p>
<img src="plangraph.png">

<p>
When each action is executed, a character is entirely controlled by
that action, and the character cannot execute the next action until
the current action is finished. Each action only considers the
starting and ending point, and it moves the character in a rather
straightforward way.  When the macro-level planner detects the
situation change (e.g. the goal is moved) during the execution, the
current plan is abandaned after the action is finished and a new plan
graph is created.

<h2>Jumping / Falling</h2>

<p>
Jumping and falling is the key element of platformer games and the
core of its planning problem. It has so many parameters that using
naive methods will easily lead to computational explosion. In the
proposed method, the macro-level planner only takes care of its
starting point and ending point in the block coordinates. The planner
has to know in advance the speed of a character in question and its
jump impulse, as well as the gravity acceleration, so that it can know
where it will exactly land. The macro-level planner uses two bounding
boxes (a jumping part and a falling part) to approximate the clearance
that a character needs, but it doesn't take care of an actual
trajectory of the character.

<p>
An actual jump action is divided into three steps.  First, it tries to
move the character to its starting position (Set), maneuver the
character movement during ascending (Ascend), and then land the
character to the ending position (Land).  It takes a precise
(pixel-wise) control of the character at each frame update.

<p>
<img src="jumping.png">

<h2>Landing Prediction</h2>

<p>
The planner can find a solution only when the path planning is
solvable. When a character is following another character that is
jumping or falling, the goal position is considered unreachable,
making it impossible to find a solution. In a case like this, the
planner can optionally make a guess of the final landing position
based on the current speed of the character.

<p>
<img src="prediction.png">

<h2>Moving Platforms</h2>

<p>
<img src="movingplatform.png">

<h2>Splinting / Double Jumping</h2>

<h2>Source Code Structure</h2>

<p>
There are several important classes that do the logic.
They are mostly separated from the UI.

<ul>
<li> <code>Actor</code>: 
  This is an object that the planner takes control of.
<li> <code>TileMap</code>:
  An object that holds the 2D map where a plan graph is based on.
  This is basically a two dimensional array of tile numbers.
<li> <code>PlanMap</code>: 
  A plan graph and its constructor.
<li> <code>PlanAction</code>: 
  This object is responsible for moving a character during a certain action. 
  Each action is represented as an edge of a plan graph.
  An action object has a detailed information about the action
  such as a starting and ending point, the type of the action, 
  and the tile map it's referring to.
</ul>

<h2>Is This Smarter than Humans?</h2>

<p>
Unfortunately, no.  Due to computational limits, the current
implementation considers only a handful of ways of possible jumps at
each position. Since it uses a rectangle as an approximation of jump
trajectory, it cannot emulate a complex manuever that humans could
do. Also, since it's on block-by-block basis, it cannot consider a
possibility of barely-make-it kinds of jumps. These are mostly
complexity problems, but in some cases there might be need to give up
to find an optimal solution.
